import numpy as np
from qutip import mesolve, basis, tensor, qeye
from scipy.linalg import expm
from scipy.optimize import curve_fit

from jc_sim_oqp.physics import driven_jc_hamiltonian, get_operators, get_initial_state

# Standard Pauli Matrices
I2 = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

# Minimal Phase Gates (Standard RB set: I, X, Y, X/2, -X/2, Y/2, -Y/2)
# These are physically easy to implement
PRIMITIVE_GATES = {
    "I": I2,
    "X": expm(-1j * (np.pi / 2) * X),  # R_x(pi)
    "Y": expm(-1j * (np.pi / 2) * Y),  # R_y(pi)
    "X/2": expm(-1j * (np.pi / 4) * X),  # R_x(pi/2)
    "-X/2": expm(-1j * (-np.pi / 4) * X),  # R_x(-pi/2)
    "Y/2": expm(-1j * (np.pi / 4) * Y),  # R_y(pi/2)
    "-Y/2": expm(-1j * (-np.pi / 4) * Y),  # R_y(-pi/2)
}


class CliffordGroup:
    """Generates the single-qubit Clifford group and handling decomposition."""

    def __init__(self):
        self.cliffords = self._generate_clifford_group()
        self.clifford_to_primitives = self._map_to_primitives()

    def _generate_clifford_group(self) -> list[np.ndarray]:
        """Generate 24 Clifford matrices by brute-force multiplication of S and H."""
        # Simple generation: Cl(1) is generated by S = Z/2 and H.
        # However, for pulse compilation, it is better to identify them by their effect.
        # Here we use a simpler approach: Just search through products of our primitives
        # until we find 24 unique operations (up to global phase).
        found = [I2]
        
        # BFS to find all 24
        queue = [I2]
        while len(found) < 24 and queue:
            current = queue.pop(0)
            for name, gate in PRIMITIVE_GATES.items():
                if name == "I":
                    continue
                next_gate = gate @ current
                
                # Check uniqueness (up to phase)
                is_new = True
                for existing in found:
                    # Check if proportional
                    # a = z * b -> tr(a b_dag) approx |a|^2
                    overlap = np.abs(np.trace(next_gate @ existing.conj().T))
                    if np.isclose(overlap, 2.0):
                        is_new = False
                        break
                
                if is_new:
                    found.append(next_gate)
                    queue.append(next_gate)
        
        return found

    def _map_to_primitives(self) -> dict[int, list[str]]:
        """Find a primitive gate decomposition for each Clifford."""
        # This is a lookup table. For this prototype, we do a quick BFS to map each of 
        # the 24 found Cliffords to a sequence of primitives.
        mapping = {}
        
        # Re-run search but store paths
        # Structure: (matrix, [list_of_names])
        queue = [(I2, ["I"])]
        
        # We need to match exactly the self.cliffords list
        cliffords_remaining = {i: c for i, c in enumerate(self.cliffords)}
        
        # Max depth 3 is usually enough for single qubit Cliffords with this set
        for depth in range(5):
            new_queue = []
            for mat, path in queue:
                # Check if this matrix matches any needed clifford
                to_remove = []
                for idx, target in cliffords_remaining.items():
                    if np.isclose(np.abs(np.trace(mat @ target.conj().T)), 2.0):
                        mapping[idx] = path
                        to_remove.append(idx)
                
                for idx in to_remove:
                    del cliffords_remaining[idx]
                
                if not cliffords_remaining:
                    break
                
                # Expand
                for name, gate in PRIMITIVE_GATES.items():
                    if name == "I": continue
                    new_path = path + [name] if path != ["I"] else [name]
                    new_queue.append((gate @ mat, new_path))
            
            queue = new_queue
            if not cliffords_remaining:
                break
                
        return mapping

    def inverse(self, sequence_indices: list[int]) -> int:
        """Find the Clifford index that inverts the given sequence."""
        # Multiply all
        total_op = I2
        for idx in sequence_indices:
            total_op = self.cliffords[idx] @ total_op
            
        # Find inverse
        inv_op = total_op.conj().T
        
        # Match to known cliffords
        for i, c in enumerate(self.cliffords):
            if np.isclose(np.abs(np.trace(inv_op @ c.conj().T)), 2.0):
                return i
        
        raise ValueError("Inverse not found in group (numerical error?)")

    def sample_sequence(self, length: int) -> list[int]:
        """Generate a random sequence of `length` Cliffords + 1 inverse."""
        # Random integers 0..23
        seq = np.random.randint(0, 24, size=length).tolist()
        inv_idx = self.inverse(seq)
        seq.append(inv_idx)
        return seq


class PulseSequence:
    """Represents a compiled sequence of pulses."""
    def __init__(self, gate_duration: float = 20e-9):
        self.gate_duration = gate_duration
        self.tlist = []
        self.drive_x = []
        self.drive_y = []
        self._current_t = 0.0

    def add_primitive(self, name: str, amplitude: float = 1.0):
        """Add a primitive gate pulse."""
        # For prototype: Square pulses
        # Area = Amp * Duration. 
        # Pi pulse (X): Area = pi. Amp = pi / Duration.
        # Pi/2 pulse (X/2): Area = pi/2. Amp = (pi/2) / Duration.
        
        duration = self.gate_duration
        
        # Determine rotation angle
        angle = 0.0
        axis = 'x'
        
        if "X" in name:
            axis = 'x'
            if "X/2" in name: angle = np.pi/2
            elif "-X/2" in name: angle = -np.pi/2
            else: angle = np.pi
        elif "Y" in name:
            axis = 'y'
            if "Y/2" in name: angle = np.pi/2
            elif "-Y/2" in name: angle = -np.pi/2
            else: angle = np.pi
        elif name == "I":
            angle = 0.0
        
        # Calculate amplitude for square pulse
        # omega * t = angle
        amp_val = angle / duration
        
        # Add to schedule (discrete steps for simplicity in checking)
        # In real code, we'd append to arrays for interpolation
        t_start = self._current_t
        t_mid = t_start + duration / 2
        t_end = t_start + duration
        
        self.tlist.extend([t_start, t_end])
        
        val_x = amp_val if axis == 'x' else 0.0
        val_y = amp_val if axis == 'y' else 0.0
        
        # We store values as (t, val) points for step-function approximation
        # Ideally, we return a function, but for mesolve step args, we might need array interpolation
        self._append_pulse(t_start, t_end, val_x, val_y)
        
        self._current_t = t_end

    def _append_pulse(self, t_start, t_end, val_x, val_y):
        """Append simple square pulse logic."""
        # For simplicity in prototype, we just store intervals
        # Real implementation would build a full array
        self.drive_x.append((t_start, t_end, val_x))
        self.drive_y.append((t_start, t_end, val_y))

    def get_drive_funcs(self):
        """Return callables for drive_x and drive_y."""
        def drive_x_func(t, args=None):
            for (start, end, val) in self.drive_x:
                if start <= t < end:
                    return val
            return 0.0

        def drive_y_func(t, args=None):
            for (start, end, val) in self.drive_y:
                if start <= t < end:
                    return val
            return 0.0
            
        return drive_x_func, drive_y_func, self._current_t


class RBSimulation:
    """Orchestrates the Pulse-Level Randomized Benchmarking experiment."""

    def __init__(
        self,
        wc: float,
        wa: float,
        g: float,
        gate_duration: float = 20e-9,
        n_atoms: int = 1
    ):
        self.wc = wc
        self.wa = wa
        self.g = g
        self.gate_duration = gate_duration
        self.n_atoms = n_atoms
        
        self.clifford_group = CliffordGroup()

    def run_sequence(self, sequence_indices: list[int], n_steps_per_gate: int = 20):
        """Compile and run a single RB sequence."""
        # 1. Compile to PulseSequence
        pulse_seq = PulseSequence(gate_duration=self.gate_duration)
        
        # Add pulses for each Clifford
        for c_idx in sequence_indices:
            primitives = self.clifford_group.clifford_to_primitives[c_idx]
            for prim in primitives:
                pulse_seq.add_primitive(prim)
                
        # Get drive functions
        drive_x, drive_y, total_time = pulse_seq.get_drive_funcs()
        
        # 2. Setup Physics
        # Operators (using small cavity dimension for efficiency)
        a, sm_list = get_operators(n_cavity=2, n_atoms=self.n_atoms)
        
        # Hamiltonian
        H = driven_jc_hamiltonian(
            self.wc, self.wa, self.g, a, sm_list,
            drive_x=drive_x, drive_y=drive_y,
            use_rwa=True
        )
        
        # Initial State: Ground state |g> x |0>
        # Note: In our convention (and QuTiP often), basis(2, 0) is spin-up/excited, basis(2, 1) is spin-down/ground.
        psi_g = tensor(basis(2, 0), basis(2, 1))
        if self.n_atoms > 1:
             psi_g = tensor(basis(2, 0), *[basis(2, 1) for _ in range(self.n_atoms)])
             
        # Time list
        tlist = np.linspace(0, total_time, int(total_time / self.gate_duration * n_steps_per_gate) + 2)
        
        # 3. Evolve
        result = mesolve(H, psi_g, tlist, [], [])
        
        return result


class RBAnalyzer:
    """Analyzes Random Benchmarking data to extract fidelity."""
    
    @staticmethod
    def fit_decay(lengths: list[int], survival_probs: list[float]) -> tuple[float, float, float]:
        """Fit the RB decay curve P(m) = A * p^m + B.
        
        Args:
            lengths: Sequence lengths (m)
            survival_probs: Survival probabilities (P(m))
            
        Returns:
            tuple: (EPC, p, fit_params)
                   EPC: Error per Clifford = (1-p)*(d-1)/d
                   p: Depolarizing parameter
                   fit_params: (A, p, B)
        """
        def rb_decay_func(m, A, p, B):
            return A * (p ** m) + B
            
        # Initial guess: A=0.5, p=0.9, B=0.5
        p0 = [0.5, 0.95, 0.5]
        bounds = ([0, 0, 0], [1, 1, 1])
        
        try:
            popt, pcov = curve_fit(rb_decay_func, lengths, survival_probs, p0=p0, bounds=bounds)
        except RuntimeError:
            # Fallback if fit fails
            return np.nan, np.nan, (np.nan, np.nan, np.nan)
            
        A, p, B = popt
        
        # Calculate Error Per Clifford (EPC)
        # r = (d-1)/d * (1-p)
        # For a single qubit, d=2 -> r = 1/2 * (1-p)
        d = 2
        r = (d - 1) / d * (1 - p)
        
        return r, p, popt


